"use strict";(self.webpackChunkpumped_fn_docs=self.webpackChunkpumped_fn_docs||[]).push([[34],{5273:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>i,default:()=>u,frontMatter:()=>c,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"testing/testing-utilities","title":"Testing Utilities","description":"This guide covers helpful utilities, patterns, and helper functions that make testing Pumped Fn applications easier and more maintainable.","source":"@site/docs/testing/testing-utilities.md","sourceDirName":"testing","slug":"/testing/testing-utilities","permalink":"/pumped-fn/docs/testing/testing-utilities","draft":false,"unlisted":false,"editUrl":"https://github.com/pumped-fn/pumped-fn/tree/main/docs/docs/testing/testing-utilities.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Testing React Components","permalink":"/pumped-fn/docs/testing/testing-react"},"next":{"title":"Interactive Testing Examples","permalink":"/pumped-fn/docs/testing/interactive-testing"}}');var s=n(6106),r=n(8018);const c={},i="Testing Utilities",a={},l=[{value:"Custom Test Helpers",id:"custom-test-helpers",level:2},{value:"Scope Testing Utilities",id:"scope-testing-utilities",level:3},{value:"React Testing Utilities",id:"react-testing-utilities",level:3},{value:"Custom Matchers",id:"custom-matchers",level:2},{value:"Vitest Custom Matchers",id:"vitest-custom-matchers",level:3},{value:"State Factory Utilities",id:"state-factory-utilities",level:2},{value:"Test Data Factories",id:"test-data-factories",level:3},{value:"Mock and Spy Utilities",id:"mock-and-spy-utilities",level:2},{value:"API Mocking",id:"api-mocking",level:3},{value:"Test Assertion Helpers",id:"test-assertion-helpers",level:2},{value:"State Assertion Utilities",id:"state-assertion-utilities",level:3},{value:"Example Usage",id:"example-usage",level:2},{value:"Complete Test Suite Example",id:"complete-test-suite-example",level:3}];function p(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"testing-utilities",children:"Testing Utilities"})}),"\n",(0,s.jsx)(t.p,{children:"This guide covers helpful utilities, patterns, and helper functions that make testing Pumped Fn applications easier and more maintainable."}),"\n",(0,s.jsx)(t.h2,{id:"custom-test-helpers",children:"Custom Test Helpers"}),"\n",(0,s.jsx)(t.h3,{id:"scope-testing-utilities",children:"Scope Testing Utilities"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'// test-utils.ts\nimport { createScope, preset, Core } from "@pumped-fn/core-next";\n\n/**\n * Creates a test scope with optional presets\n */\nexport function createTestScope(...presets: Core.Preset<unknown>[]) {\n  return createScope(...presets);\n}\n\n/**\n * Helper for testing executor resolution\n */\nexport async function resolveExecutor<T>(\n  executor: Core.Executor<T>,\n  scope?: Core.Scope\n): Promise<T> {\n  const testScope = scope || createScope();\n  return await testScope.resolve(executor);\n}\n\n/**\n * Helper for testing reactive chains\n */\nexport async function testReactiveChain<S, D>(\n  source: Core.Executor<S>,\n  derived: Core.Executor<D>,\n  updates: S[]\n): Promise<D[]> {\n  const scope = createScope();\n  const results: D[] = [];\n  \n  // Initial value\n  results.push(await scope.resolve(derived));\n  \n  // Apply updates and collect results\n  for (const update of updates) {\n    await scope.update(source, update);\n    results.push(await scope.resolve(derived));\n  }\n  \n  return results;\n}\n\n/**\n * Helper for testing cleanup behavior\n */\nexport async function testCleanup(\n  executor: Core.Executor<unknown>,\n  expectedCleanupCalls: number = 1\n): Promise<{ cleanup: vi.MockedFunction<any>, scope: Core.Scope }> {\n  const cleanup = vi.fn();\n  \n  const testExecutor = derive([executor], ([value], controller) => {\n    controller.cleanup(cleanup);\n    return value;\n  });\n  \n  const scope = createScope();\n  await scope.resolve(testExecutor);\n  \n  return { cleanup, scope };\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"react-testing-utilities",children:"React Testing Utilities"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'// react-test-utils.tsx\nimport React from "react";\nimport { render, RenderOptions } from "@testing-library/react";\nimport { createScope, preset, Core } from "@pumped-fn/core-next";\nimport { ScopeProvider } from "@pumped-fn/react";\n\ninterface CustomRenderOptions extends Omit<RenderOptions, \'wrapper\'> {\n  scope?: Core.Scope;\n  presets?: Core.Preset<unknown>[];\n}\n\n/**\n * Custom render function with ScopeProvider\n */\nexport function renderWithScope(\n  ui: React.ReactElement,\n  { scope, presets = [], ...options }: CustomRenderOptions = {}\n) {\n  const testScope = scope || createScope(...presets);\n  \n  function Wrapper({ children }: { children: React.ReactNode }) {\n    return <ScopeProvider scope={testScope}>{children}</ScopeProvider>;\n  }\n  \n  return {\n    ...render(ui, { wrapper: Wrapper, ...options }),\n    scope: testScope,\n  };\n}\n\n/**\n * Wrapper for testing components in isolation\n */\nexport function createComponentWrapper(\n  scope?: Core.Scope,\n  presets: Core.Preset<unknown>[] = []\n) {\n  const testScope = scope || createScope(...presets);\n  \n  return {\n    Wrapper: ({ children }: { children: React.ReactNode }) => (\n      <ScopeProvider scope={testScope}>{children}</ScopeProvider>\n    ),\n    scope: testScope,\n  };\n}\n\n/**\n * Helper for testing async components with Suspense\n */\nexport function renderWithSuspense(\n  ui: React.ReactElement,\n  { fallback = "Loading...", ...options }: CustomRenderOptions & { fallback?: React.ReactNode } = {}\n) {\n  const WrappedComponent = (\n    <React.Suspense fallback={<div data-testid="loading">{fallback}</div>}>\n      {ui}\n    </React.Suspense>\n  );\n  \n  return renderWithScope(WrappedComponent, options);\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"custom-matchers",children:"Custom Matchers"}),"\n",(0,s.jsx)(t.h3,{id:"vitest-custom-matchers",children:"Vitest Custom Matchers"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'// test-matchers.ts\nimport { expect } from "vitest";\nimport { createScope, Core } from "@pumped-fn/core-next";\n\ninterface CustomMatchers<R = unknown> {\n  toResolveWith(expected: unknown): R;\n  toResolveWithin(timeout: number): R;\n  toFailWith(errorMessage: string): R;\n}\n\ndeclare module "vitest" {\n  interface Assertion<T = any> extends CustomMatchers<T> {}\n  interface AsymmetricMatchersContaining extends CustomMatchers {}\n}\n\nexpect.extend({\n  async toResolveWith(executor: Core.Executor<unknown>, expected: unknown) {\n    const scope = createScope();\n    \n    try {\n      const actual = await scope.resolve(executor);\n      const pass = this.equals(actual, expected);\n      \n      return {\n        pass,\n        message: () =>\n          pass\n            ? `Expected executor not to resolve with ${this.utils.printExpected(expected)}`\n            : `Expected executor to resolve with ${this.utils.printExpected(expected)}, but got ${this.utils.printReceived(actual)}`,\n      };\n    } catch (error) {\n      return {\n        pass: false,\n        message: () =>\n          `Expected executor to resolve with ${this.utils.printExpected(expected)}, but it threw: ${error}`,\n      };\n    }\n  },\n\n  async toResolveWithin(executor: Core.Executor<unknown>, timeout: number) {\n    const scope = createScope();\n    const startTime = Date.now();\n    \n    try {\n      await scope.resolve(executor);\n      const duration = Date.now() - startTime;\n      const pass = duration <= timeout;\n      \n      return {\n        pass,\n        message: () =>\n          pass\n            ? `Expected executor to take longer than ${timeout}ms, but resolved in ${duration}ms`\n            : `Expected executor to resolve within ${timeout}ms, but took ${duration}ms`,\n      };\n    } catch (error) {\n      return {\n        pass: false,\n        message: () => `Expected executor to resolve within ${timeout}ms, but it threw: ${error}`,\n      };\n    }\n  },\n\n  async toFailWith(executor: Core.Executor<unknown>, errorMessage: string) {\n    const scope = createScope();\n    \n    try {\n      await scope.resolve(executor);\n      return {\n        pass: false,\n        message: () => `Expected executor to throw "${errorMessage}", but it resolved successfully`,\n      };\n    } catch (error) {\n      const pass = error.message.includes(errorMessage);\n      \n      return {\n        pass,\n        message: () =>\n          pass\n            ? `Expected executor not to throw "${errorMessage}"`\n            : `Expected executor to throw "${errorMessage}", but got "${error.message}"`,\n      };\n    }\n  },\n});\n\n// Usage examples:\n// await expect(myExecutor).toResolveWith(expectedValue);\n// await expect(asyncExecutor).toResolveWithin(1000);\n// await expect(failingExecutor).toFailWith("Network error");\n'})}),"\n",(0,s.jsx)(t.h2,{id:"state-factory-utilities",children:"State Factory Utilities"}),"\n",(0,s.jsx)(t.h3,{id:"test-data-factories",children:"Test Data Factories"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'// test-factories.ts\nimport { provide, derive } from "@pumped-fn/core-next";\n\n/**\n * Factory for creating test counter state\n */\nexport function createTestCounter(initialValue: number = 0) {\n  const counter = provide(() => initialValue);\n  const doubled = derive([counter.reactive], ([count]) => count * 2);\n  const isEven = derive([counter.reactive], ([count]) => count % 2 === 0);\n  \n  const controller = derive([counter.static], ([ref]) => ({\n    increment: () => ref.update(c => c + 1),\n    decrement: () => ref.update(c => c - 1),\n    set: (value: number) => ref.update(value),\n    reset: () => ref.update(initialValue),\n  }));\n  \n  return {\n    counter,\n    doubled,\n    isEven,\n    controller,\n  };\n}\n\n/**\n * Factory for creating test todo state\n */\nexport function createTestTodos(initialTodos: Todo[] = []) {\n  const todos = provide(() => initialTodos);\n  \n  const completedTodos = derive([todos.reactive], ([list]) =>\n    list.filter(todo => todo.completed)\n  );\n  \n  const activeTodos = derive([todos.reactive], ([list]) =>\n    list.filter(todo => !todo.completed)\n  );\n  \n  const controller = derive([todos.static], ([ref]) => ({\n    add: (text: string) => {\n      ref.update(list => [...list, {\n        id: Date.now().toString(),\n        text,\n        completed: false,\n      }]);\n    },\n    toggle: (id: string) => {\n      ref.update(list =>\n        list.map(todo =>\n          todo.id === id ? { ...todo, completed: !todo.completed } : todo\n        )\n      );\n    },\n    remove: (id: string) => {\n      ref.update(list => list.filter(todo => todo.id !== id));\n    },\n    clear: () => ref.update([]),\n  }));\n  \n  return {\n    todos,\n    completedTodos,\n    activeTodos,\n    controller,\n  };\n}\n\n/**\n * Factory for creating test user state\n */\nexport function createTestUser(initialUser?: Partial<User>) {\n  const defaultUser: User = {\n    id: 1,\n    name: "Test User",\n    email: "test@example.com",\n    settings: {\n      theme: "light",\n      notifications: true,\n    },\n    ...initialUser,\n  };\n  \n  const user = provide(() => defaultUser);\n  \n  const userProfile = derive([user.reactive], ([u]) => ({\n    displayName: u.name,\n    avatar: `https://avatar.example.com/${u.id}`,\n    initials: u.name\n      .split(" ")\n      .map(n => n[0])\n      .join("")\n      .toUpperCase(),\n  }));\n  \n  const userPreferences = derive([user.reactive], ([u]) => u.settings);\n  \n  const controller = derive([user.static], ([ref]) => ({\n    updateName: (name: string) => ref.update(u => ({ ...u, name })),\n    updateEmail: (email: string) => ref.update(u => ({ ...u, email })),\n    updateSettings: (settings: Partial<UserSettings>) =>\n      ref.update(u => ({\n        ...u,\n        settings: { ...u.settings, ...settings },\n      })),\n  }));\n  \n  return {\n    user,\n    userProfile,\n    userPreferences,\n    controller,\n  };\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"mock-and-spy-utilities",children:"Mock and Spy Utilities"}),"\n",(0,s.jsx)(t.h3,{id:"api-mocking",children:"API Mocking"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'// api-mocks.ts\nimport { vi } from "vitest";\nimport { provide, derive } from "@pumped-fn/core-next";\n\n/**\n * Creates a mock API client\n */\nexport function createMockApi() {\n  const mockFetch = vi.fn();\n  const mockGet = vi.fn();\n  const mockPost = vi.fn();\n  const mockPut = vi.fn();\n  const mockDelete = vi.fn();\n  \n  const api = provide(() => ({\n    fetch: mockFetch,\n    get: mockGet,\n    post: mockPost,\n    put: mockPut,\n    delete: mockDelete,\n  }));\n  \n  const apiHelpers = {\n    mockSuccess: (data: any) => {\n      mockFetch.mockResolvedValue({ ok: true, json: () => Promise.resolve(data) });\n      mockGet.mockResolvedValue(data);\n      mockPost.mockResolvedValue(data);\n      mockPut.mockResolvedValue(data);\n      mockDelete.mockResolvedValue(data);\n    },\n    \n    mockError: (error: string) => {\n      const errorResponse = new Error(error);\n      mockFetch.mockRejectedValue(errorResponse);\n      mockGet.mockRejectedValue(errorResponse);\n      mockPost.mockRejectedValue(errorResponse);\n      mockPut.mockRejectedValue(errorResponse);\n      mockDelete.mockRejectedValue(errorResponse);\n    },\n    \n    mockLoading: (delay: number = 1000) => {\n      const pendingPromise = new Promise(resolve => setTimeout(resolve, delay));\n      mockFetch.mockReturnValue(pendingPromise);\n      mockGet.mockReturnValue(pendingPromise);\n      mockPost.mockReturnValue(pendingPromise);\n      mockPut.mockReturnValue(pendingPromise);\n      mockDelete.mockReturnValue(pendingPromise);\n    },\n    \n    getMocks: () => ({\n      fetch: mockFetch,\n      get: mockGet,\n      post: mockPost,\n      put: mockPut,\n      delete: mockDelete,\n    }),\n  };\n  \n  return { api, ...apiHelpers };\n}\n\n/**\n * Creates a mock timer utility\n */\nexport function createMockTimer() {\n  const callbacks = new Set<() => void>();\n  \n  const timer = provide(() => ({\n    setInterval: (callback: () => void, ms: number) => {\n      callbacks.add(callback);\n      return setInterval(callback, ms);\n    },\n    clearInterval: (id: number) => {\n      clearInterval(id);\n    },\n    tick: () => {\n      callbacks.forEach(callback => callback());\n    },\n  }));\n  \n  return {\n    timer,\n    tick: () => {\n      callbacks.forEach(callback => callback());\n    },\n    clearAll: () => {\n      callbacks.clear();\n    },\n  };\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"test-assertion-helpers",children:"Test Assertion Helpers"}),"\n",(0,s.jsx)(t.h3,{id:"state-assertion-utilities",children:"State Assertion Utilities"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'// assertion-helpers.ts\nimport { Core, createScope } from "@pumped-fn/core-next";\n\n/**\n * Asserts that an executor resolves to the expected value\n */\nexport async function assertResolves<T>(\n  executor: Core.Executor<T>,\n  expected: T,\n  scope?: Core.Scope\n): Promise<void> {\n  const testScope = scope || createScope();\n  const actual = await testScope.resolve(executor);\n  expect(actual).toEqual(expected);\n}\n\n/**\n * Asserts that an executor throws the expected error\n */\nexport async function assertThrows(\n  executor: Core.Executor<unknown>,\n  expectedError: string | RegExp,\n  scope?: Core.Scope\n): Promise<void> {\n  const testScope = scope || createScope();\n  await expect(testScope.resolve(executor)).rejects.toThrow(expectedError);\n}\n\n/**\n * Asserts that a reactive chain works correctly\n */\nexport async function assertReactiveChain<S, D>(\n  source: Core.Executor<S>,\n  derived: Core.Executor<D>,\n  updates: Array<{ input: S; expected: D }>,\n  scope?: Core.Scope\n): Promise<void> {\n  const testScope = scope || createScope();\n  \n  for (const { input, expected } of updates) {\n    await testScope.update(source, input);\n    const actual = await testScope.resolve(derived);\n    expect(actual).toEqual(expected);\n  }\n}\n\n/**\n * Asserts that cleanup functions are called\n */\nexport async function assertCleanup(\n  executor: Core.Executor<unknown>,\n  expectedCalls: number = 1,\n  scope?: Core.Scope\n): Promise<vi.MockedFunction<any>> {\n  const cleanup = vi.fn();\n  const testScope = scope || createScope();\n  \n  const wrappedExecutor = derive([executor], ([value], controller) => {\n    controller.cleanup(cleanup);\n    return value;\n  });\n  \n  await testScope.resolve(wrappedExecutor);\n  await testScope.release(wrappedExecutor);\n  \n  expect(cleanup).toHaveBeenCalledTimes(expectedCalls);\n  return cleanup;\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"example-usage",children:"Example Usage"}),"\n",(0,s.jsx)(t.h3,{id:"complete-test-suite-example",children:"Complete Test Suite Example"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'// complete-test-example.test.ts\nimport { vi, test, expect, describe, beforeEach } from "vitest";\nimport { renderWithScope, createTestCounter, assertResolves } from "./test-utils";\nimport { fireEvent, screen, waitFor } from "@testing-library/react";\n\ndescribe("Counter with Test Utilities", () => {\n  let counterState: ReturnType<typeof createTestCounter>;\n  \n  beforeEach(() => {\n    counterState = createTestCounter(10);\n  });\n  \n  test("executor behavior", async () => {\n    const { counter, doubled, controller } = counterState;\n    \n    // Test initial values\n    await assertResolves(counter, 10);\n    await assertResolves(doubled, 20);\n    \n    // Test reactive updates\n    await assertReactiveChain(counter, doubled, [\n      { input: 5, expected: 10 },\n      { input: 0, expected: 0 },\n      { input: -3, expected: -6 },\n    ]);\n  });\n  \n  test("component integration", async () => {\n    const { counter, doubled, controller } = counterState;\n    \n    function TestComponent() {\n      const [count, doubledValue, ctrl] = useResolves(counter, doubled, controller);\n      \n      return (\n        <div>\n          <span data-testid="count">{count}</span>\n          <span data-testid="doubled">{doubledValue}</span>\n          <button onClick={ctrl.increment} data-testid="increment">\n            +\n          </button>\n        </div>\n      );\n    }\n    \n    renderWithScope(<TestComponent />);\n    \n    expect(screen.getByTestId("count")).toHaveTextContent("10");\n    expect(screen.getByTestId("doubled")).toHaveTextContent("20");\n    \n    fireEvent.click(screen.getByTestId("increment"));\n    \n    await waitFor(() => {\n      expect(screen.getByTestId("count")).toHaveTextContent("11");\n      expect(screen.getByTestId("doubled")).toHaveTextContent("22");\n    });\n  });\n});\n'})}),"\n",(0,s.jsx)(t.p,{children:"These testing utilities make your Pumped Fn tests more maintainable, readable, and less repetitive while providing powerful assertion capabilities."})]})}function u(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},8018:(e,t,n)=>{n.d(t,{R:()=>c,x:()=>i});var o=n(7378);const s={},r=o.createContext(s);function c(e){const t=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),o.createElement(r.Provider,{value:t},e.children)}}}]);