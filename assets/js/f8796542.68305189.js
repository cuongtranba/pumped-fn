"use strict";(self.webpackChunkpumped_fn_docs=self.webpackChunkpumped_fn_docs||[]).push([[240],{8018:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var s=n(7378);const r={},i=s.createContext(r);function o(e){const t=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:t},e.children)}},8638:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"testing/overview","title":"Testing Overview","description":"Testing applications built with Pumped Fn is straightforward and powerful thanks to the built-in preset feature. Instead of complex mocking, you can easily simulate different application states by presetting executor values and observing how your derived state and components behave.","source":"@site/docs/testing/overview.md","sourceDirName":"testing","slug":"/testing/overview","permalink":"/pumped-fn/docs/testing/overview","draft":false,"unlisted":false,"editUrl":"https://github.com/pumped-fn/pumped-fn/tree/main/docs/docs/testing/overview.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"React Integration Overview","permalink":"/pumped-fn/docs/react/overview"},"next":{"title":"Testing Executors","permalink":"/pumped-fn/docs/testing/testing-executors"}}');var r=n(6106),i=n(8018);const o={},a="Testing Overview",c={},l=[{value:"Testing Philosophy",id:"testing-philosophy",level:2},{value:"Testing Tools",id:"testing-tools",level:2},{value:"Core Testing Stack",id:"core-testing-stack",level:3},{value:"Setup Example",id:"setup-example",level:3},{value:"The <code>preset</code> Approach",id:"the-preset-approach",level:2},{value:"What to Test",id:"what-to-test",level:2},{value:"1. Derived State Logic",id:"1-derived-state-logic",level:3},{value:"2. Component Behavior",id:"2-component-behavior",level:3},{value:"3. Complex State Interactions",id:"3-complex-state-interactions",level:3},{value:"Testing Patterns",id:"testing-patterns",level:2},{value:"State Simulation with Preset",id:"state-simulation-with-preset",level:3},{value:"Testing Complex Derivations",id:"testing-complex-derivations",level:3},{value:"Testing React Components with Different States",id:"testing-react-components-with-different-states",level:3},{value:"Advanced Testing Scenarios",id:"advanced-testing-scenarios",level:2},{value:"Testing Error States",id:"testing-error-states",level:3},{value:"Testing Async Behavior",id:"testing-async-behavior",level:3},{value:"Testing Conditional Logic",id:"testing-conditional-logic",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Use Preset for State Simulation",id:"1-use-preset-for-state-simulation",level:3},{value:"2. Test Business Logic, Not Implementation",id:"2-test-business-logic-not-implementation",level:3},{value:"3. Create Meaningful Test Scenarios",id:"3-create-meaningful-test-scenarios",level:3},{value:"4. Test Edge Cases with Preset",id:"4-test-edge-cases-with-preset",level:3},{value:"5. Keep Tests Readable",id:"5-keep-tests-readable",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"testing-overview",children:"Testing Overview"})}),"\n",(0,r.jsxs)(t.p,{children:["Testing applications built with Pumped Fn is straightforward and powerful thanks to the built-in ",(0,r.jsx)(t.code,{children:"preset"})," feature. Instead of complex mocking, you can easily simulate different application states by presetting executor values and observing how your derived state and components behave."]}),"\n",(0,r.jsx)(t.h2,{id:"testing-philosophy",children:"Testing Philosophy"}),"\n",(0,r.jsx)(t.p,{children:"Pumped Fn's testing approach is designed around:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"State Simulation"}),": Use ",(0,r.jsx)(t.code,{children:"preset"})," to simulate different application states"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Derived Logic Testing"}),": Test how your derived state responds to different inputs"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Component Behavior"}),": Test React components under various state conditions"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Integration Testing"}),": Test how different parts of your application work together"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"No Mocking Required"}),": Built-in tools eliminate the need for complex mocking"]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"testing-tools",children:"Testing Tools"}),"\n",(0,r.jsx)(t.p,{children:"Pumped Fn works excellently with modern testing tools:"}),"\n",(0,r.jsx)(t.h3,{id:"core-testing-stack",children:"Core Testing Stack"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"https://vitest.dev/",children:"Vitest"})})," - Fast unit testing framework"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"https://testing-library.com/docs/react-testing-library/intro/",children:"@testing-library/react"})})," - React component testing"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.a,{href:"https://github.com/testing-library/jest-dom",children:"@testing-library/jest-dom"})})," - Additional jest matchers"]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"setup-example",children:"Setup Example"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'// vitest.config.ts\nimport { defineConfig } from "vitest/config";\n\nexport default defineConfig({\n  test: {\n    environment: "jsdom", // For React testing\n    globals: true,\n    setupFiles: ["./tests/setup.ts"],\n  },\n});\n'})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'// tests/setup.ts\nimport "@testing-library/jest-dom";\n'})}),"\n",(0,r.jsxs)(t.h2,{id:"the-preset-approach",children:["The ",(0,r.jsx)(t.code,{children:"preset"})," Approach"]}),"\n",(0,r.jsxs)(t.p,{children:["The key to testing with Pumped Fn is the ",(0,r.jsx)(t.code,{children:"preset"})," function. Instead of mocking, you create test scopes with specific executor values preset to simulate different application states."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'import { createScope, preset } from "@pumped-fn/core-next";\n\n// Your application state\nconst user = provide(() => null);\nconst isLoggedIn = derive([user.reactive], ([u]) => u !== null);\n\n// Test different scenarios by presetting values\nconst loggedOutScope = createScope(); // user defaults to null\nconst loggedInScope = createScope(preset(user, { id: 1, name: "John" }));\n'})}),"\n",(0,r.jsx)(t.h2,{id:"what-to-test",children:"What to Test"}),"\n",(0,r.jsx)(t.h3,{id:"1-derived-state-logic",children:"1. Derived State Logic"}),"\n",(0,r.jsx)(t.p,{children:"Test how your business logic responds to different input states:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'test("user status derivation", async () => {\n  // Test logged out state\n  const loggedOutResult = await loggedOutScope.resolve(isLoggedIn);\n  expect(loggedOutResult).toBe(false);\n  \n  // Test logged in state  \n  const loggedInResult = await loggedInScope.resolve(isLoggedIn);\n  expect(loggedInResult).toBe(true);\n});\n'})}),"\n",(0,r.jsx)(t.h3,{id:"2-component-behavior",children:"2. Component Behavior"}),"\n",(0,r.jsx)(t.p,{children:"Test how components render under different state conditions:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'test("dashboard shows correct content", () => {\n  // Test with logged out user\n  const { getByText } = render(\n    <ScopeProvider scope={loggedOutScope}>\n      <Dashboard />\n    </ScopeProvider>\n  );\n  expect(getByText("Please log in")).toBeInTheDocument();\n  \n  // Test with logged in user\n  const { getByText: getByTextLoggedIn } = render(\n    <ScopeProvider scope={loggedInScope}>\n      <Dashboard />\n    </ScopeProvider>\n  );\n  expect(getByTextLoggedIn("Welcome, John")).toBeInTheDocument();\n});\n'})}),"\n",(0,r.jsx)(t.h3,{id:"3-complex-state-interactions",children:"3. Complex State Interactions"}),"\n",(0,r.jsx)(t.p,{children:"Test how multiple parts of your state work together:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'const cart = provide(() => []);\nconst cartTotal = derive([cart.reactive], ([items]) => \n  items.reduce((sum, item) => sum + item.price, 0)\n);\n\ntest("cart calculations", async () => {\n  const testScope = createScope(preset(cart, [\n    { id: 1, price: 10.99 },\n    { id: 2, price: 25.50 }\n  ]));\n  \n  const total = await testScope.resolve(cartTotal);\n  expect(total).toBe(36.49);\n});\n'})}),"\n",(0,r.jsx)(t.h2,{id:"testing-patterns",children:"Testing Patterns"}),"\n",(0,r.jsx)(t.h3,{id:"state-simulation-with-preset",children:"State Simulation with Preset"}),"\n",(0,r.jsxs)(t.p,{children:["The most powerful pattern is using ",(0,r.jsx)(t.code,{children:"preset"})," to simulate different application states:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'import { test, expect } from "vitest";\nimport { provide, derive, createScope, preset } from "@pumped-fn/core-next";\n\n// Application state\nconst currentUser = provide(() => null);\nconst userSettings = provide(() => ({ theme: "light", notifications: true }));\nconst isAdmin = derive([currentUser.reactive], ([user]) => user?.role === "admin");\n\ntest("admin privileges", async () => {\n  // Test regular user\n  const userScope = createScope(\n    preset(currentUser, { id: 1, name: "John", role: "user" })\n  );\n  expect(await userScope.resolve(isAdmin)).toBe(false);\n  \n  // Test admin user\n  const adminScope = createScope(\n    preset(currentUser, { id: 2, name: "Jane", role: "admin" })\n  );\n  expect(await adminScope.resolve(isAdmin)).toBe(true);\n});\n'})}),"\n",(0,r.jsx)(t.h3,{id:"testing-complex-derivations",children:"Testing Complex Derivations"}),"\n",(0,r.jsx)(t.p,{children:"Test business logic by presetting inputs and observing outputs:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'const orders = provide(() => []);\nconst inventory = provide(() => new Map());\n\nconst canFulfillOrders = derive(\n  [orders.reactive, inventory.reactive],\n  ([orderList, stock]) => {\n    return orderList.every(order => \n      order.items.every(item => \n        (stock.get(item.productId) || 0) >= item.quantity\n      )\n    );\n  }\n);\n\ntest("order fulfillment logic", async () => {\n  const testOrders = [\n    { id: 1, items: [{ productId: "A", quantity: 2 }] },\n    { id: 2, items: [{ productId: "B", quantity: 1 }] }\n  ];\n  \n  // Test insufficient inventory\n  const lowStockScope = createScope(\n    preset(orders, testOrders),\n    preset(inventory, new Map([["A", 1], ["B", 0]])) // Not enough stock\n  );\n  expect(await lowStockScope.resolve(canFulfillOrders)).toBe(false);\n  \n  // Test sufficient inventory\n  const goodStockScope = createScope(\n    preset(orders, testOrders),\n    preset(inventory, new Map([["A", 5], ["B", 3]])) // Enough stock\n  );\n  expect(await goodStockScope.resolve(canFulfillOrders)).toBe(true);\n});\n'})}),"\n",(0,r.jsx)(t.h3,{id:"testing-react-components-with-different-states",children:"Testing React Components with Different States"}),"\n",(0,r.jsx)(t.p,{children:"Use preset scopes to test components under various conditions:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:'import { render, screen } from "@testing-library/react";\nimport { provide, derive, preset, createScope } from "@pumped-fn/core-next";\nimport { useResolves, ScopeProvider } from "@pumped-fn/react";\n\nconst user = provide(() => null);\nconst theme = provide(() => "light");\nconst userGreeting = derive(\n  [user.reactive, theme.reactive],\n  ([user, theme]) => ({\n    message: user ? `Hello, ${user.name}!` : "Please log in",\n    className: theme === "dark" ? "dark-theme" : "light-theme"\n  })\n);\n\nfunction Greeting() {\n  const [greeting] = useResolves(userGreeting);\n  return (\n    <div className={greeting.className} data-testid="greeting">\n      {greeting.message}\n    </div>\n  );\n}\n\ntest("greeting component states", () => {\n  // Test logged out state\n  const loggedOutScope = createScope(); // user defaults to null\n  const { container: loggedOut } = render(\n    <ScopeProvider scope={loggedOutScope}>\n      <Greeting />\n    </ScopeProvider>\n  );\n  expect(screen.getByTestId("greeting")).toHaveTextContent("Please log in");\n  expect(loggedOut.firstChild).toHaveClass("light-theme");\n  \n  // Test logged in with dark theme\n  const loggedInDarkScope = createScope(\n    preset(user, { id: 1, name: "Alice" }),\n    preset(theme, "dark")\n  );\n  const { container: loggedInDark } = render(\n    <ScopeProvider scope={loggedInDarkScope}>\n      <Greeting />\n    </ScopeProvider>\n  );\n  expect(screen.getByTestId("greeting")).toHaveTextContent("Hello, Alice!");\n  expect(loggedInDark.firstChild).toHaveClass("dark-theme");\n});\n'})}),"\n",(0,r.jsx)(t.h2,{id:"advanced-testing-scenarios",children:"Advanced Testing Scenarios"}),"\n",(0,r.jsx)(t.h3,{id:"testing-error-states",children:"Testing Error States"}),"\n",(0,r.jsx)(t.p,{children:"Use preset to simulate error conditions and test how your application handles them:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'const apiStatus = provide(() => "success");\nconst userData = derive([apiStatus.reactive], ([status]) => {\n  if (status === "error") {\n    throw new Error("Failed to load user data");\n  }\n  return { id: 1, name: "User" };\n});\n\nconst userDisplay = derive([userData], ([user]) => `Welcome ${user.name}`);\n\ntest("error handling in derivation chain", async () => {\n  // Test success case\n  const successScope = createScope(preset(apiStatus, "success"));\n  expect(await successScope.resolve(userDisplay)).toBe("Welcome User");\n  \n  // Test error case\n  const errorScope = createScope(preset(apiStatus, "error"));\n  await expect(errorScope.resolve(userDisplay)).rejects.toThrow("Failed to load user data");\n});\n'})}),"\n",(0,r.jsx)(t.h3,{id:"testing-async-behavior",children:"Testing Async Behavior"}),"\n",(0,r.jsx)(t.p,{children:"Preset async executors to test different timing scenarios:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'const apiData = provide(async () => {\n  // In real app, this would be an API call\n  await new Promise(resolve => setTimeout(resolve, 1000));\n  return { items: [] };\n});\n\ntest("async data loading", async () => {\n  // Test with preset data (no async wait)\n  const testScope = createScope(preset(apiData, { items: ["item1", "item2"] }));\n  const result = await testScope.resolve(apiData);\n  expect(result.items).toHaveLength(2);\n});\n'})}),"\n",(0,r.jsx)(t.h3,{id:"testing-conditional-logic",children:"Testing Conditional Logic"}),"\n",(0,r.jsx)(t.p,{children:"Use preset to test different branches of conditional derivations:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'const userRole = provide(() => "guest");\nconst featureFlags = provide(() => ({ betaFeatures: false }));\n\nconst availableFeatures = derive(\n  [userRole.reactive, featureFlags.reactive],\n  ([role, flags]) => {\n    const features = ["dashboard"];\n    \n    if (role === "admin") {\n      features.push("admin-panel", "user-management");\n    }\n    \n    if (role === "user" || role === "admin") {\n      features.push("profile", "settings");\n    }\n    \n    if (flags.betaFeatures && role !== "guest") {\n      features.push("beta-feature");\n    }\n    \n    return features;\n  }\n);\n\ntest("feature availability logic", async () => {\n  // Test guest user\n  const guestScope = createScope(preset(userRole, "guest"));\n  expect(await guestScope.resolve(availableFeatures)).toEqual(["dashboard"]);\n  \n  // Test regular user\n  const userScope = createScope(preset(userRole, "user"));\n  expect(await userScope.resolve(availableFeatures)).toEqual([\n    "dashboard", "profile", "settings"\n  ]);\n  \n  // Test admin user\n  const adminScope = createScope(preset(userRole, "admin"));\n  expect(await adminScope.resolve(availableFeatures)).toEqual([\n    "dashboard", "admin-panel", "user-management", "profile", "settings"\n  ]);\n  \n  // Test user with beta features\n  const betaUserScope = createScope(\n    preset(userRole, "user"),\n    preset(featureFlags, { betaFeatures: true })\n  );\n  expect(await betaUserScope.resolve(availableFeatures)).toEqual([\n    "dashboard", "profile", "settings", "beta-feature"\n  ]);\n});\n'})}),"\n",(0,r.jsx)(t.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(t.h3,{id:"1-use-preset-for-state-simulation",children:"1. Use Preset for State Simulation"}),"\n",(0,r.jsxs)(t.p,{children:["Instead of complex mocking, use ",(0,r.jsx)(t.code,{children:"preset"})," to simulate different application states:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"// \u274c Avoid complex mocking\nconst mockApi = vi.fn().mockResolvedValue(userData);\n\n// \u2705 Use preset for clean state simulation\nconst testScope = createScope(preset(currentUser, userData));\n"})}),"\n",(0,r.jsx)(t.h3,{id:"2-test-business-logic-not-implementation",children:"2. Test Business Logic, Not Implementation"}),"\n",(0,r.jsx)(t.p,{children:"Focus on testing the behavior of your derived state:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'// \u274c Testing implementation details\ntest("executor internal behavior", async () => {\n  const executor = provide(() => 0);\n  expect(executor.factory).toBeInstanceOf(Function);\n});\n\n// \u2705 Testing business logic\ntest("discount calculation", async () => {\n  const testScope = createScope(\n    preset(cartTotal, 100),\n    preset(userLevel, "premium")\n  );\n  expect(await testScope.resolve(finalPrice)).toBe(85); // 15% discount\n});\n'})}),"\n",(0,r.jsx)(t.h3,{id:"3-create-meaningful-test-scenarios",children:"3. Create Meaningful Test Scenarios"}),"\n",(0,r.jsx)(t.p,{children:"Use preset to create realistic application states:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'test("checkout flow for different user types", async () => {\n  const newUserScope = createScope(\n    preset(user, { id: 1, accountAge: 0, verified: false }),\n    preset(cart, [{ id: "item1", price: 50 }])\n  );\n  \n  const premiumUserScope = createScope(\n    preset(user, { id: 2, accountAge: 365, verified: true }),\n    preset(cart, [{ id: "item1", price: 50 }])\n  );\n  \n  // Test different checkout experiences\n  expect(await newUserScope.resolve(checkoutFlow)).toEqual({\n    requiresVerification: true,\n    shippingOptions: ["standard"],\n    paymentMethods: ["card"]\n  });\n  \n  expect(await premiumUserScope.resolve(checkoutFlow)).toEqual({\n    requiresVerification: false,\n    shippingOptions: ["standard", "express", "overnight"],\n    paymentMethods: ["card", "paypal", "store-credit"]\n  });\n});\n'})}),"\n",(0,r.jsx)(t.h3,{id:"4-test-edge-cases-with-preset",children:"4. Test Edge Cases with Preset"}),"\n",(0,r.jsx)(t.p,{children:"Use preset to easily test boundary conditions:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'test("edge cases for order processing", async () => {\n  // Test empty cart\n  const emptyCartScope = createScope(preset(cart, []));\n  expect(await emptyCartScope.resolve(canCheckout)).toBe(false);\n  \n  // Test maximum items\n  const maxItemsScope = createScope(preset(cart, new Array(100).fill({ price: 1 })));\n  expect(await maxItemsScope.resolve(cartWarnings)).toContain("Cart limit reached");\n  \n  // Test zero-price items\n  const freebieScope = createScope(preset(cart, [{ price: 0, name: "Free sample" }]));\n  expect(await freebieScope.resolve(cartTotal)).toBe(0);\n});\n'})}),"\n",(0,r.jsx)(t.h3,{id:"5-keep-tests-readable",children:"5. Keep Tests Readable"}),"\n",(0,r.jsx)(t.p,{children:"Use descriptive preset values that make test intent clear:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'test("notification preferences", async () => {\n  const marketingOptOutScope = createScope(\n    preset(userPreferences, {\n      marketing: false,\n      security: true,\n      updates: true\n    })\n  );\n  \n  const allNotificationsScope = createScope(\n    preset(userPreferences, {\n      marketing: true,\n      security: true,\n      updates: true\n    })\n  );\n  \n  // Clear test intent from the preset values\n  expect(await marketingOptOutScope.resolve(emailTypes)).not.toContain("marketing");\n  expect(await allNotificationsScope.resolve(emailTypes)).toContain("marketing");\n});\n'})}),"\n",(0,r.jsx)(t.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"/pumped-fn/docs/testing/testing-executors",children:"Testing Executors"})," - Deep dive into executor testing"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"/pumped-fn/docs/testing/testing-react",children:"Testing React Components"})," - React-specific testing patterns"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"/pumped-fn/docs/testing/testing-utilities",children:"Testing Utilities"})," - Helper functions and testing tools"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"/pumped-fn/docs/testing/interactive-testing",children:"Interactive Testing Examples"})," - Live, runnable testing examples"]}),"\n"]})]})}function p(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);