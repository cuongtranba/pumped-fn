"use strict";(self.webpackChunkpumped_fn_docs=self.webpackChunkpumped_fn_docs||[]).push([[279],{5714:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"testing/testing-executors","title":"Testing Executors","description":"This guide covers comprehensive testing strategies for Pumped Fn executors, including basic state, derived state, and complex interactions.","source":"@site/docs/testing/testing-executors.md","sourceDirName":"testing","slug":"/testing/testing-executors","permalink":"/pumped-fn/docs/testing/testing-executors","draft":false,"unlisted":false,"editUrl":"https://github.com/pumped-fn/pumped-fn/tree/main/docs/docs/testing/testing-executors.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Testing Overview","permalink":"/pumped-fn/docs/testing/overview"},"next":{"title":"Testing React Components","permalink":"/pumped-fn/docs/testing/testing-react"}}');var c=t(6106),a=t(8018);const o={},r="Testing Executors",i={},l=[{value:"Basic Executor Testing",id:"basic-executor-testing",level:2},{value:"Testing Simple State",id:"testing-simple-state",level:3},{value:"Testing Factory Functions",id:"testing-factory-functions",level:3},{value:"Testing Derived State",id:"testing-derived-state",level:2},{value:"Basic Derivations",id:"basic-derivations",level:3},{value:"Object Dependencies",id:"object-dependencies",level:3},{value:"Reactive Updates",id:"reactive-updates",level:3},{value:"Testing Executor Variants",id:"testing-executor-variants",level:2},{value:"Static Dependencies",id:"static-dependencies",level:3},{value:"Lazy Dependencies",id:"lazy-dependencies",level:3},{value:"Testing Side Effects and Cleanup",id:"testing-side-effects-and-cleanup",level:2},{value:"Basic Cleanup",id:"basic-cleanup",level:3},{value:"Resource Management",id:"resource-management",level:3},{value:"Testing Async Executors",id:"testing-async-executors",level:2},{value:"Promise-based State",id:"promise-based-state",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Testing Complex Scenarios",id:"testing-complex-scenarios",level:2},{value:"Multiple Scopes",id:"multiple-scopes",level:3},{value:"Presets",id:"presets",level:3},{value:"Performance Testing",id:"performance-testing",level:2},{value:"Memory Management",id:"memory-management",level:3},{value:"Subscription Management",id:"subscription-management",level:3},{value:"Testing Utilities",id:"testing-utilities",level:2},{value:"Custom Matchers",id:"custom-matchers",level:3},{value:"Test Helpers",id:"test-helpers",level:3}];function p(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(n.header,{children:(0,c.jsx)(n.h1,{id:"testing-executors",children:"Testing Executors"})}),"\n",(0,c.jsx)(n.p,{children:"This guide covers comprehensive testing strategies for Pumped Fn executors, including basic state, derived state, and complex interactions."}),"\n",(0,c.jsx)(n.h2,{id:"basic-executor-testing",children:"Basic Executor Testing"}),"\n",(0,c.jsx)(n.h3,{id:"testing-simple-state",children:"Testing Simple State"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:'import { vi, test, expect } from "vitest";\nimport { provide, createScope } from "@pumped-fn/core-next";\n\ntest("basic state executor", async () => {\n  // Arrange\n  const initialState = { count: 0, name: "test" };\n  const state = provide(() => initialState);\n  const scope = createScope();\n  \n  // Act\n  const result = await scope.resolve(state);\n  \n  // Assert\n  expect(result).toEqual(initialState);\n  expect(result).not.toBe(initialState); // Should be a copy\n});\n\ntest("state updates", async () => {\n  const counter = provide(() => 0);\n  const scope = createScope();\n  \n  // Initial value\n  expect(await scope.resolve(counter)).toBe(0);\n  \n  // Update with value\n  await scope.update(counter, 5);\n  expect(await scope.resolve(counter)).toBe(5);\n  \n  // Update with function\n  await scope.update(counter, (current) => current + 3);\n  expect(await scope.resolve(counter)).toBe(8);\n});\n'})}),"\n",(0,c.jsx)(n.h3,{id:"testing-factory-functions",children:"Testing Factory Functions"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:'test("factory function is called correctly", async () => {\n  const factory = vi.fn(() => ({ initialized: true }));\n  const executor = provide(factory);\n  const scope = createScope();\n  \n  // Factory not called until resolved\n  expect(factory).not.toHaveBeenCalled();\n  \n  const result = await scope.resolve(executor);\n  \n  // Factory called exactly once\n  expect(factory).toHaveBeenCalledTimes(1);\n  expect(result).toEqual({ initialized: true });\n  \n  // Subsequent resolves don\'t call factory again\n  await scope.resolve(executor);\n  expect(factory).toHaveBeenCalledTimes(1);\n});\n'})}),"\n",(0,c.jsx)(n.h2,{id:"testing-derived-state",children:"Testing Derived State"}),"\n",(0,c.jsx)(n.h3,{id:"basic-derivations",children:"Basic Derivations"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:'test("derived state computation", async () => {\n  const base = provide(() => 10);\n  const doubled = derive([base.reactive], ([value]) => value * 2);\n  const scope = createScope();\n  \n  expect(await scope.resolve(doubled)).toBe(20);\n  \n  await scope.update(base, 15);\n  expect(await scope.resolve(doubled)).toBe(30);\n});\n\ntest("multiple dependencies", async () => {\n  const a = provide(() => 5);\n  const b = provide(() => 3);\n  const sum = derive([a.reactive, b.reactive], ([aVal, bVal]) => aVal + bVal);\n  const scope = createScope();\n  \n  expect(await scope.resolve(sum)).toBe(8);\n  \n  await scope.update(a, 10);\n  expect(await scope.resolve(sum)).toBe(13);\n  \n  await scope.update(b, 7);\n  expect(await scope.resolve(sum)).toBe(17);\n});\n'})}),"\n",(0,c.jsx)(n.h3,{id:"object-dependencies",children:"Object Dependencies"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:'test("object-shaped dependencies", async () => {\n  const user = provide(() => ({ name: "John", age: 30 }));\n  const settings = provide(() => ({ theme: "dark", language: "en" }));\n  \n  const profile = derive(\n    { user: user.reactive, settings: settings.reactive },\n    ({ user, settings }) => ({\n      displayName: user.name,\n      theme: settings.theme,\n      isAdult: user.age >= 18\n    })\n  );\n  \n  const scope = createScope();\n  const result = await scope.resolve(profile);\n  \n  expect(result).toEqual({\n    displayName: "John",\n    theme: "dark",\n    isAdult: true\n  });\n});\n'})}),"\n",(0,c.jsx)(n.h3,{id:"reactive-updates",children:"Reactive Updates"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:'test("reactive dependency updates", async () => {\n  const computationMock = vi.fn((value) => value * 2);\n  const source = provide(() => 1);\n  const derived = derive([source.reactive], ([value]) => computationMock(value));\n  \n  const scope = createScope();\n  \n  // Initial computation\n  await scope.resolve(derived);\n  expect(computationMock).toHaveBeenCalledTimes(1);\n  expect(computationMock).toHaveBeenCalledWith(1);\n  \n  // Update triggers recomputation\n  await scope.update(source, 5);\n  await scope.resolve(derived);\n  expect(computationMock).toHaveBeenCalledTimes(2);\n  expect(computationMock).toHaveBeenCalledWith(5);\n});\n'})}),"\n",(0,c.jsx)(n.h2,{id:"testing-executor-variants",children:"Testing Executor Variants"}),"\n",(0,c.jsx)(n.h3,{id:"static-dependencies",children:"Static Dependencies"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:'test("static dependencies provide accessor", async () => {\n  const counter = provide(() => 0);\n  const controller = derive([counter.static], ([accessor]) => ({\n    increment: () => accessor.update(c => c + 1),\n    decrement: () => accessor.update(c => c - 1),\n    getValue: () => accessor.get()\n  }));\n  \n  const scope = createScope();\n  const ctrl = await scope.resolve(controller);\n  await scope.resolve(counter); // Initialize counter\n  \n  expect(ctrl.getValue()).toBe(0);\n  \n  await ctrl.increment();\n  expect(ctrl.getValue()).toBe(1);\n  \n  await ctrl.decrement();\n  expect(ctrl.getValue()).toBe(0);\n});\n'})}),"\n",(0,c.jsx)(n.h3,{id:"lazy-dependencies",children:"Lazy Dependencies"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:'test("lazy dependencies are not auto-resolved", async () => {\n  const expensive = vi.fn(() => "expensive computation");\n  const expensiveExecutor = provide(expensive);\n  \n  const controller = derive([expensiveExecutor.lazy], ([lazyAccessor]) => ({\n    compute: () => lazyAccessor.resolve(),\n    hasValue: () => !!lazyAccessor.lookup()\n  }));\n  \n  const scope = createScope();\n  const ctrl = await scope.resolve(controller);\n  \n  // Expensive computation not called yet\n  expect(expensive).not.toHaveBeenCalled();\n  expect(ctrl.hasValue()).toBe(false);\n  \n  // Manually trigger computation\n  await ctrl.compute();\n  expect(expensive).toHaveBeenCalledTimes(1);\n  expect(ctrl.hasValue()).toBe(true);\n});\n'})}),"\n",(0,c.jsx)(n.h2,{id:"testing-side-effects-and-cleanup",children:"Testing Side Effects and Cleanup"}),"\n",(0,c.jsx)(n.h3,{id:"basic-cleanup",children:"Basic Cleanup"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:'test("cleanup functions are called", async () => {\n  const cleanup = vi.fn();\n  \n  const executor = derive([], (_, controller) => {\n    controller.cleanup(cleanup);\n    return "value";\n  });\n  \n  const scope = createScope();\n  await scope.resolve(executor);\n  \n  expect(cleanup).not.toHaveBeenCalled();\n  \n  await scope.release(executor);\n  expect(cleanup).toHaveBeenCalledTimes(1);\n});\n\ntest("cleanup on update", async () => {\n  const cleanup = vi.fn();\n  const trigger = provide(() => 0);\n  \n  const sideEffect = derive([trigger.reactive], ([value], controller) => {\n    controller.cleanup(cleanup);\n    return `value-${value}`;\n  });\n  \n  const scope = createScope();\n  await scope.resolve(sideEffect);\n  \n  // Update triggers cleanup and re-execution\n  await scope.update(trigger, 1);\n  expect(cleanup).toHaveBeenCalledTimes(1);\n  \n  await scope.update(trigger, 2);\n  expect(cleanup).toHaveBeenCalledTimes(2);\n});\n'})}),"\n",(0,c.jsx)(n.h3,{id:"resource-management",children:"Resource Management"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:'test("timer management", async () => {\n  vi.useFakeTimers();\n  \n  const interval = provide(() => 1000);\n  const callback = vi.fn();\n  \n  const timer = derive([interval.reactive], ([ms], controller) => {\n    const id = setInterval(callback, ms);\n    controller.cleanup(() => clearInterval(id));\n    return id;\n  });\n  \n  const scope = createScope();\n  const timerId = await scope.resolve(timer);\n  \n  expect(typeof timerId).toBe("number");\n  expect(callback).not.toHaveBeenCalled();\n  \n  // Advance time\n  vi.advanceTimersByTime(1000);\n  expect(callback).toHaveBeenCalledTimes(1);\n  \n  vi.advanceTimersByTime(1000);\n  expect(callback).toHaveBeenCalledTimes(2);\n  \n  // Update interval - should cleanup old timer\n  await scope.update(interval, 500);\n  callback.mockClear();\n  \n  vi.advanceTimersByTime(500);\n  expect(callback).toHaveBeenCalledTimes(1);\n  \n  vi.useRealTimers();\n});\n'})}),"\n",(0,c.jsx)(n.h2,{id:"testing-async-executors",children:"Testing Async Executors"}),"\n",(0,c.jsx)(n.h3,{id:"promise-based-state",children:"Promise-based State"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:'test("async executor resolution", async () => {\n  const asyncData = provide(async () => {\n    await new Promise(resolve => setTimeout(resolve, 100));\n    return { loaded: true, data: "test" };\n  });\n  \n  const scope = createScope();\n  const result = await scope.resolve(asyncData);\n  \n  expect(result).toEqual({ loaded: true, data: "test" });\n});\n\ntest("async dependency chains", async () => {\n  const fetchUser = provide(async () => ({ id: 1, name: "John" }));\n  const fetchUserPosts = derive([fetchUser], async ([user]) => {\n    // Simulate API call\n    await new Promise(resolve => setTimeout(resolve, 50));\n    return [`Post 1 by ${user.name}`, `Post 2 by ${user.name}`];\n  });\n  \n  const scope = createScope();\n  const posts = await scope.resolve(fetchUserPosts);\n  \n  expect(posts).toEqual(["Post 1 by John", "Post 2 by John"]);\n});\n'})}),"\n",(0,c.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:'test("async error handling", async () => {\n  const failingExecutor = provide(async () => {\n    await new Promise(resolve => setTimeout(resolve, 10));\n    throw new Error("Network error");\n  });\n  \n  const scope = createScope();\n  \n  await expect(scope.resolve(failingExecutor)).rejects.toThrow("Network error");\n});\n\ntest("error recovery", async () => {\n  let shouldFail = true;\n  const unstableExecutor = provide(async () => {\n    if (shouldFail) {\n      shouldFail = false;\n      throw new Error("Temporary failure");\n    }\n    return "success";\n  });\n  \n  const scope = createScope();\n  \n  // First attempt fails\n  await expect(scope.resolve(unstableExecutor)).rejects.toThrow("Temporary failure");\n  \n  // Force re-resolution\n  const result = await scope.resolve(unstableExecutor, true);\n  expect(result).toBe("success");\n});\n'})}),"\n",(0,c.jsx)(n.h2,{id:"testing-complex-scenarios",children:"Testing Complex Scenarios"}),"\n",(0,c.jsx)(n.h3,{id:"multiple-scopes",children:"Multiple Scopes"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:'test("isolated scopes", async () => {\n  const counter = provide(() => 0);\n  \n  const scope1 = createScope();\n  const scope2 = createScope();\n  \n  await scope1.update(counter, 5);\n  await scope2.update(counter, 10);\n  \n  expect(await scope1.resolve(counter)).toBe(5);\n  expect(await scope2.resolve(counter)).toBe(10);\n});\n'})}),"\n",(0,c.jsx)(n.h3,{id:"presets",children:"Presets"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:'test("preset values", async () => {\n  const config = provide(() => ({ env: "development" }));\n  const app = derive([config], ([cfg]) => `App running in ${cfg.env}`);\n  \n  // Default scope\n  const defaultScope = createScope();\n  expect(await defaultScope.resolve(app)).toBe("App running in development");\n  \n  // Scope with preset\n  const prodScope = createScope(preset(config, { env: "production" }));\n  expect(await prodScope.resolve(app)).toBe("App running in production");\n});\n'})}),"\n",(0,c.jsx)(n.h2,{id:"performance-testing",children:"Performance Testing"}),"\n",(0,c.jsx)(n.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:'test("memory cleanup on scope disposal", async () => {\n  const heavyData = provide(() => new Array(1000000).fill("data"));\n  const scope = createScope();\n  \n  await scope.resolve(heavyData);\n  \n  // Dispose scope and verify cleanup\n  await scope.dispose();\n  \n  // Access should throw after disposal\n  expect(() => scope.resolve(heavyData)).toThrow();\n});\n'})}),"\n",(0,c.jsx)(n.h3,{id:"subscription-management",children:"Subscription Management"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:'test("subscription cleanup", async () => {\n  const source = provide(() => 0);\n  const listener = vi.fn();\n  \n  const scope = createScope();\n  await scope.resolve(source);\n  \n  const cleanup = scope.onUpdate(source, listener);\n  \n  await scope.update(source, 1);\n  expect(listener).toHaveBeenCalledTimes(1);\n  \n  cleanup();\n  \n  await scope.update(source, 2);\n  expect(listener).toHaveBeenCalledTimes(1); // Not called after cleanup\n});\n'})}),"\n",(0,c.jsx)(n.h2,{id:"testing-utilities",children:"Testing Utilities"}),"\n",(0,c.jsx)(n.h3,{id:"custom-matchers",children:"Custom Matchers"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:"// Custom matcher for executor values\nexpect.extend({\n  async toResolveWith(executor, expected) {\n    const scope = createScope();\n    const actual = await scope.resolve(executor);\n    \n    return {\n      pass: this.equals(actual, expected),\n      message: () => `Expected executor to resolve with ${expected}, got ${actual}`\n    };\n  }\n});\n\n// Usage\nawait expect(myExecutor).toResolveWith(expectedValue);\n"})}),"\n",(0,c.jsx)(n.h3,{id:"test-helpers",children:"Test Helpers"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:"// Helper for testing reactive chains\nasync function testReactiveChain(source, derived, updates) {\n  const scope = createScope();\n  const results = [];\n  \n  for (const update of updates) {\n    await scope.update(source, update);\n    results.push(await scope.resolve(derived));\n  }\n  \n  return results;\n}\n\n// Usage\nconst results = await testReactiveChain(\n  counter,\n  doubled,\n  [1, 2, 3, 4]\n);\nexpect(results).toEqual([2, 4, 6, 8]);\n"})}),"\n",(0,c.jsx)(n.p,{children:"This comprehensive testing approach ensures your Pumped Fn executors are reliable, performant, and maintainable."})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(p,{...e})}):p(e)}},8018:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var s=t(7378);const c={},a=s.createContext(c);function o(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:o(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);