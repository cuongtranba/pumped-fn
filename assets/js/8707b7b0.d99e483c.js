"use strict";(self.webpackChunkpumped_fn_docs=self.webpackChunkpumped_fn_docs||[]).push([[692],{249:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"testing/testing-react","title":"Testing React Components","description":"This guide covers testing React components that use Pumped Fn state management, including hooks, components, and complex interactions.","source":"@site/docs/testing/testing-react.md","sourceDirName":"testing","slug":"/testing/testing-react","permalink":"/pumped-fn/docs/testing/testing-react","draft":false,"unlisted":false,"editUrl":"https://github.com/pumped-fn/pumped-fn/tree/main/docs/docs/testing/testing-react.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Testing Executors","permalink":"/pumped-fn/docs/testing/testing-executors"},"next":{"title":"Testing Utilities","permalink":"/pumped-fn/docs/testing/testing-utilities"}}');var s=t(6106),r=t(8018);const i={},d="Testing React Components",a={},c=[{value:"Setup for React Testing",id:"setup-for-react-testing",level:2},{value:"Test Configuration",id:"test-configuration",level:3},{value:"Dependencies",id:"dependencies",level:3},{value:"Testing Hooks",id:"testing-hooks",level:2},{value:"Basic Hook Testing",id:"basic-hook-testing",level:3},{value:"Testing Multiple Hooks",id:"testing-multiple-hooks",level:3},{value:"Testing useResolve with Selectors",id:"testing-useresolve-with-selectors",level:3},{value:"Testing Components",id:"testing-components",level:2},{value:"Basic Component Testing",id:"basic-component-testing",level:3},{value:"Testing Form Components",id:"testing-form-components",level:3},{value:"Testing List Components",id:"testing-list-components",level:3},{value:"Testing Async Components",id:"testing-async-components",level:2},{value:"Suspense Integration",id:"suspense-integration",level:3},{value:"Error Boundaries",id:"error-boundaries",level:3},{value:"Testing Component Patterns",id:"testing-component-patterns",level:2},{value:"Conditional Rendering",id:"conditional-rendering",level:3},{value:"Component Composition",id:"component-composition",level:3},{value:"Testing Performance",id:"testing-performance",level:2},{value:"Re-render Optimization",id:"re-render-optimization",level:3},{value:"Testing Utilities",id:"testing-utilities",level:2},{value:"Custom Render Function",id:"custom-render-function",level:3},{value:"State Helpers",id:"state-helpers",level:3}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"testing-react-components",children:"Testing React Components"})}),"\n",(0,s.jsx)(n.p,{children:"This guide covers testing React components that use Pumped Fn state management, including hooks, components, and complex interactions."}),"\n",(0,s.jsx)(n.h2,{id:"setup-for-react-testing",children:"Setup for React Testing"}),"\n",(0,s.jsx)(n.h3,{id:"test-configuration",children:"Test Configuration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'// vitest.config.ts\nimport { defineConfig } from "vitest/config";\n\nexport default defineConfig({\n  test: {\n    environment: "jsdom",\n    globals: true,\n    setupFiles: ["./tests/setup.ts"],\n  },\n});\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'// tests/setup.ts\nimport "@testing-library/jest-dom";\n\n// Optional: Suppress React development warnings in tests\nconst originalError = console.error;\nconsole.error = (...args) => {\n  if (typeof args[0] === "string" && args[0].includes("useEffect")) {\n    return;\n  }\n  originalError.call(console, ...args);\n};\n'})}),"\n",(0,s.jsx)(n.h3,{id:"dependencies",children:"Dependencies"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "devDependencies": {\n    "@testing-library/react": "^14.0.0",\n    "@testing-library/jest-dom": "^6.0.0",\n    "@testing-library/user-event": "^14.0.0",\n    "vitest": "^1.0.0",\n    "jsdom": "^23.0.0"\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"testing-hooks",children:"Testing Hooks"}),"\n",(0,s.jsx)(n.h3,{id:"basic-hook-testing",children:"Basic Hook Testing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'import { renderHook, waitFor } from "@testing-library/react";\nimport { provide, derive, createScope } from "@pumped-fn/core-next";\nimport { useResolves, ScopeProvider } from "@pumped-fn/react";\n\ntest("useResolves basic usage", async () => {\n  const counter = provide(() => 0);\n  const doubled = derive([counter.reactive], ([count]) => count * 2);\n  \n  const { result } = renderHook(\n    () => useResolves(counter, doubled),\n    {\n      wrapper: ({ children }) => (\n        <ScopeProvider>\n          {children}\n        </ScopeProvider>\n      ),\n    }\n  );\n  \n  await waitFor(() => {\n    expect(result.current[0]).toBe(0); // counter\n    expect(result.current[1]).toBe(0); // doubled\n  });\n});\n\ntest("useResolves with updates", async () => {\n  const counter = provide(() => 0);\n  const scope = createScope();\n  \n  const { result } = renderHook(\n    () => useResolves(counter),\n    {\n      wrapper: ({ children }) => (\n        <ScopeProvider scope={scope}>\n          {children}\n        </ScopeProvider>\n      ),\n    }\n  );\n  \n  // Initial value\n  await waitFor(() => {\n    expect(result.current[0]).toBe(0);\n  });\n  \n  // Update externally\n  await scope.update(counter, 5);\n  \n  await waitFor(() => {\n    expect(result.current[0]).toBe(5);\n  });\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"testing-multiple-hooks",children:"Testing Multiple Hooks"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'test("multiple hooks working together", async () => {\n  const count = provide(() => 0);\n  const doubled = derive([count.reactive], ([c]) => c * 2);\n  const tripled = derive([count.reactive], ([c]) => c * 3);\n  \n  const { result } = renderHook(\n    () => {\n      const [countValue] = useResolves(count);\n      const [doubledValue] = useResolves(doubled);\n      const [tripledValue] = useResolves(tripled);\n      \n      return { countValue, doubledValue, tripledValue };\n    },\n    {\n      wrapper: ({ children }) => <ScopeProvider>{children}</ScopeProvider>,\n    }\n  );\n  \n  await waitFor(() => {\n    expect(result.current.countValue).toBe(0);\n    expect(result.current.doubledValue).toBe(0);\n    expect(result.current.tripledValue).toBe(0);\n  });\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"testing-useresolve-with-selectors",children:"Testing useResolve with Selectors"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'test("useResolve with selector", async () => {\n  const user = provide(() => ({\n    id: 1,\n    name: "John",\n    email: "john@example.com",\n    settings: { theme: "dark" }\n  }));\n  \n  const { result } = renderHook(\n    () => {\n      const name = useResolve(user, (u) => u.name);\n      const theme = useResolve(user, (u) => u.settings.theme);\n      return { name, theme };\n    },\n    {\n      wrapper: ({ children }) => <ScopeProvider>{children}</ScopeProvider>,\n    }\n  );\n  \n  await waitFor(() => {\n    expect(result.current.name).toBe("John");\n    expect(result.current.theme).toBe("dark");\n  });\n});\n'})}),"\n",(0,s.jsx)(n.h2,{id:"testing-components",children:"Testing Components"}),"\n",(0,s.jsx)(n.h3,{id:"basic-component-testing",children:"Basic Component Testing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'import { render, screen, fireEvent, waitFor } from "@testing-library/react";\nimport { provide, derive } from "@pumped-fn/core-next";\nimport { useResolves, ScopeProvider } from "@pumped-fn/react";\n\n// Test component\nconst counter = provide(() => 0);\nconst doubled = derive([counter.reactive], ([count]) => count * 2);\n\nfunction Counter() {\n  const [count, doubledValue] = useResolves(counter, doubled);\n  \n  return (\n    <div>\n      <span data-testid="count">{count}</span>\n      <span data-testid="doubled">{doubledValue}</span>\n      <button \n        data-testid="increment"\n        onClick={() => counter.update(c => c + 1)}\n      >\n        Increment\n      </button>\n    </div>\n  );\n}\n\ntest("counter component renders and updates", async () => {\n  render(\n    <ScopeProvider>\n      <Counter />\n    </ScopeProvider>\n  );\n  \n  // Initial state\n  expect(screen.getByTestId("count")).toHaveTextContent("0");\n  expect(screen.getByTestId("doubled")).toHaveTextContent("0");\n  \n  // Click increment\n  fireEvent.click(screen.getByTestId("increment"));\n  \n  // Wait for updates\n  await waitFor(() => {\n    expect(screen.getByTestId("count")).toHaveTextContent("1");\n    expect(screen.getByTestId("doubled")).toHaveTextContent("2");\n  });\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"testing-form-components",children:"Testing Form Components"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'const formData = provide(() => ({ name: "", email: "" }));\nconst isValid = derive([formData.reactive], ([data]) => \n  data.name.length > 0 && data.email.includes("@")\n);\n\nfunction UserForm() {\n  const [data, valid] = useResolves(formData, isValid);\n  \n  const updateField = (field: string) => (value: string) => {\n    formData.update(current => ({ ...current, [field]: value }));\n  };\n  \n  return (\n    <form>\n      <input\n        data-testid="name"\n        value={data.name}\n        onChange={(e) => updateField("name")(e.target.value)}\n        placeholder="Name"\n      />\n      <input\n        data-testid="email"\n        value={data.email}\n        onChange={(e) => updateField("email")(e.target.value)}\n        placeholder="Email"\n      />\n      <button \n        data-testid="submit"\n        type="submit" \n        disabled={!valid}\n      >\n        Submit\n      </button>\n    </form>\n  );\n}\n\ntest("form validation", async () => {\n  const user = userEvent.setup();\n  \n  render(\n    <ScopeProvider>\n      <UserForm />\n    </ScopeProvider>\n  );\n  \n  const submitButton = screen.getByTestId("submit");\n  expect(submitButton).toBeDisabled();\n  \n  // Fill name\n  await user.type(screen.getByTestId("name"), "John Doe");\n  expect(submitButton).toBeDisabled(); // Still invalid\n  \n  // Fill email\n  await user.type(screen.getByTestId("email"), "john@example.com");\n  \n  await waitFor(() => {\n    expect(submitButton).toBeEnabled();\n  });\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"testing-list-components",children:"Testing List Components"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'const todos = provide(() => [] as Array<{ id: string; text: string; done: boolean }>);\n\nconst todosController = derive([todos.static], ([todosRef]) => ({\n  add: (text: string) => {\n    todosRef.update(list => [...list, {\n      id: Date.now().toString(),\n      text,\n      done: false\n    }]);\n  },\n  toggle: (id: string) => {\n    todosRef.update(list => \n      list.map(todo => \n        todo.id === id ? { ...todo, done: !todo.done } : todo\n      )\n    );\n  },\n  remove: (id: string) => {\n    todosRef.update(list => list.filter(todo => todo.id !== id));\n  }\n}));\n\nfunction TodoList() {\n  const [todoList, controller] = useResolves(todos, todosController);\n  \n  return (\n    <div>\n      <ul data-testid="todo-list">\n        {todoList.map(todo => (\n          <li key={todo.id} data-testid={`todo-${todo.id}`}>\n            <span style={{ textDecoration: todo.done ? "line-through" : "none" }}>\n              {todo.text}\n            </span>\n            <button onClick={() => controller.toggle(todo.id)}>\n              Toggle\n            </button>\n            <button onClick={() => controller.remove(todo.id)}>\n              Remove\n            </button>\n          </li>\n        ))}\n      </ul>\n      <button \n        data-testid="add-todo"\n        onClick={() => controller.add("New Todo")}\n      >\n        Add Todo\n      </button>\n    </div>\n  );\n}\n\ntest("todo list operations", async () => {\n  render(\n    <ScopeProvider>\n      <TodoList />\n    </ScopeProvider>\n  );\n  \n  // Initially empty\n  expect(screen.getByTestId("todo-list")).toBeEmptyDOMElement();\n  \n  // Add todo\n  fireEvent.click(screen.getByTestId("add-todo"));\n  \n  await waitFor(() => {\n    expect(screen.getByText("New Todo")).toBeInTheDocument();\n  });\n  \n  // Toggle todo\n  fireEvent.click(screen.getByText("Toggle"));\n  \n  await waitFor(() => {\n    const todoText = screen.getByText("New Todo");\n    expect(todoText).toHaveStyle("text-decoration: line-through");\n  });\n});\n'})}),"\n",(0,s.jsx)(n.h2,{id:"testing-async-components",children:"Testing Async Components"}),"\n",(0,s.jsx)(n.h3,{id:"suspense-integration",children:"Suspense Integration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'const asyncData = provide(async () => {\n  await new Promise(resolve => setTimeout(resolve, 100));\n  return { message: "Data loaded!" };\n});\n\nfunction AsyncComponent() {\n  const [data] = useResolves(asyncData);\n  return <div data-testid="async-data">{data.message}</div>;\n}\n\nfunction App() {\n  return (\n    <ScopeProvider>\n      <Suspense fallback={<div data-testid="loading">Loading...</div>}>\n        <AsyncComponent />\n      </Suspense>\n    </ScopeProvider>\n  );\n}\n\ntest("async component with suspense", async () => {\n  render(<App />);\n  \n  // Initially shows loading\n  expect(screen.getByTestId("loading")).toBeInTheDocument();\n  \n  // Wait for data to load\n  await waitFor(() => {\n    expect(screen.getByTestId("async-data")).toHaveTextContent("Data loaded!");\n  });\n  \n  expect(screen.queryByTestId("loading")).not.toBeInTheDocument();\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"error-boundaries",children:"Error Boundaries"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'class ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n  \n  static getDerivedStateFromError(error) {\n    return { hasError: true };\n  }\n  \n  render() {\n    if (this.state.hasError) {\n      return <div data-testid="error">Something went wrong!</div>;\n    }\n    return this.props.children;\n  }\n}\n\nconst failingData = provide(async () => {\n  await new Promise(resolve => setTimeout(resolve, 50));\n  throw new Error("Network error");\n});\n\nfunction FailingComponent() {\n  const [data] = useResolves(failingData);\n  return <div>{data}</div>;\n}\n\ntest("error handling with error boundary", async () => {\n  render(\n    <ErrorBoundary>\n      <ScopeProvider>\n        <Suspense fallback={<div>Loading...</div>}>\n          <FailingComponent />\n        </Suspense>\n      </ScopeProvider>\n    </ErrorBoundary>\n  );\n  \n  await waitFor(() => {\n    expect(screen.getByTestId("error")).toBeInTheDocument();\n  });\n});\n'})}),"\n",(0,s.jsx)(n.h2,{id:"testing-component-patterns",children:"Testing Component Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"conditional-rendering",children:"Conditional Rendering"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'const isLoggedIn = provide(() => false);\nconst user = provide(() => ({ name: "John Doe" }));\n\nfunction ConditionalComponent() {\n  const [loggedIn, userData] = useResolves(isLoggedIn, user);\n  \n  if (loggedIn) {\n    return <div data-testid="welcome">Welcome, {userData.name}!</div>;\n  }\n  \n  return (\n    <button \n      data-testid="login"\n      onClick={() => isLoggedIn.update(true)}\n    >\n      Login\n    </button>\n  );\n}\n\ntest("conditional rendering based on state", async () => {\n  render(\n    <ScopeProvider>\n      <ConditionalComponent />\n    </ScopeProvider>\n  );\n  \n  // Initially shows login button\n  expect(screen.getByTestId("login")).toBeInTheDocument();\n  expect(screen.queryByTestId("welcome")).not.toBeInTheDocument();\n  \n  // Click login\n  fireEvent.click(screen.getByTestId("login"));\n  \n  await waitFor(() => {\n    expect(screen.getByTestId("welcome")).toHaveTextContent("Welcome, John Doe!");\n    expect(screen.queryByTestId("login")).not.toBeInTheDocument();\n  });\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"component-composition",children:"Component Composition"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// Parent component that provides state\nfunction TodoApp() {\n  return (\n    <ScopeProvider>\n      <div>\n        <TodoForm />\n        <TodoList />\n        <TodoStats />\n      </div>\n    </ScopeProvider>\n  );\n}\n\nconst completedCount = derive([todos.reactive], ([todoList]) => \n  todoList.filter(todo => todo.done).length\n);\n\nfunction TodoStats() {\n  const [total, completed] = useResolves(\n    derive([todos.reactive], ([list]) => list.length),\n    completedCount\n  );\n  \n  return (\n    <div data-testid="stats">\n      {completed} of {total} completed\n    </div>\n  );\n}\n\ntest("component composition sharing state", async () => {\n  render(<TodoApp />);\n  \n  // Initial state\n  expect(screen.getByTestId("stats")).toHaveTextContent("0 of 0 completed");\n  \n  // Add todos and verify stats update\n  fireEvent.click(screen.getByTestId("add-todo"));\n  \n  await waitFor(() => {\n    expect(screen.getByTestId("stats")).toHaveTextContent("0 of 1 completed");\n  });\n  \n  // Toggle completion\n  fireEvent.click(screen.getByText("Toggle"));\n  \n  await waitFor(() => {\n    expect(screen.getByTestId("stats")).toHaveTextContent("1 of 1 completed");\n  });\n});\n'})}),"\n",(0,s.jsx)(n.h2,{id:"testing-performance",children:"Testing Performance"}),"\n",(0,s.jsx)(n.h3,{id:"re-render-optimization",children:"Re-render Optimization"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'test("component re-render optimization", async () => {\n  const renderCount = vi.fn();\n  const user = provide(() => ({ \n    name: "John", \n    email: "john@example.com",\n    settings: { theme: "dark" }\n  }));\n  \n  function NameComponent() {\n    renderCount();\n    const name = useResolve(user, (u) => u.name);\n    return <div data-testid="name">{name}</div>;\n  }\n  \n  const scope = createScope();\n  \n  render(\n    <ScopeProvider scope={scope}>\n      <NameComponent />\n    </ScopeProvider>\n  );\n  \n  await waitFor(() => {\n    expect(screen.getByTestId("name")).toHaveTextContent("John");\n  });\n  \n  expect(renderCount).toHaveBeenCalledTimes(1);\n  \n  // Update email (should not trigger re-render of name component)\n  await scope.update(user, current => ({ ...current, email: "new@example.com" }));\n  \n  // Should not re-render because name didn\'t change\n  expect(renderCount).toHaveBeenCalledTimes(1);\n  \n  // Update name (should trigger re-render)\n  await scope.update(user, current => ({ ...current, name: "Jane" }));\n  \n  await waitFor(() => {\n    expect(screen.getByTestId("name")).toHaveTextContent("Jane");\n  });\n  \n  expect(renderCount).toHaveBeenCalledTimes(2);\n});\n'})}),"\n",(0,s.jsx)(n.h2,{id:"testing-utilities",children:"Testing Utilities"}),"\n",(0,s.jsx)(n.h3,{id:"custom-render-function",children:"Custom Render Function"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// Test utilities\nfunction renderWithScope(ui: React.ReactElement, { scope, ...options } = {}) {\n  const testScope = scope || createScope();\n  \n  function Wrapper({ children }: { children: React.ReactNode }) {\n    return <ScopeProvider scope={testScope}>{children}</ScopeProvider>;\n  }\n  \n  return {\n    ...render(ui, { wrapper: Wrapper, ...options }),\n    scope: testScope\n  };\n}\n\n// Usage\ntest("using custom render utility", async () => {\n  const counter = provide(() => 0);\n  \n  function Counter() {\n    const [count] = useResolves(counter);\n    return <div data-testid="count">{count}</div>;\n  }\n  \n  const { scope } = renderWithScope(<Counter />);\n  \n  expect(screen.getByTestId("count")).toHaveTextContent("0");\n  \n  await scope.update(counter, 5);\n  \n  await waitFor(() => {\n    expect(screen.getByTestId("count")).toHaveTextContent("5");\n  });\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"state-helpers",children:"State Helpers"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// Helper for setting up test state\nfunction createTestState() {\n  const todos = provide(() => [\n    { id: "1", text: "Test todo 1", done: false },\n    { id: "2", text: "Test todo 2", done: true }\n  ]);\n  \n  const controller = derive([todos.static], ([todosRef]) => ({\n    add: (text: string) => {\n      todosRef.update(list => [...list, {\n        id: Date.now().toString(),\n        text,\n        done: false\n      }]);\n    },\n    // ... other methods\n  }));\n  \n  return { todos, controller };\n}\n\ntest("using state helper", async () => {\n  const { todos, controller } = createTestState();\n  \n  function TodoApp() {\n    const [todoList, ctrl] = useResolves(todos, controller);\n    return (\n      <div>\n        <div data-testid="count">{todoList.length}</div>\n        <button onClick={() => ctrl.add("New todo")}>Add</button>\n      </div>\n    );\n  }\n  \n  renderWithScope(<TodoApp />);\n  \n  expect(screen.getByTestId("count")).toHaveTextContent("2");\n  \n  fireEvent.click(screen.getByText("Add"));\n  \n  await waitFor(() => {\n    expect(screen.getByTestId("count")).toHaveTextContent("3");\n  });\n});\n'})}),"\n",(0,s.jsx)(n.p,{children:"This comprehensive React testing approach ensures your Pumped Fn React integrations are reliable and perform well in real-world scenarios."})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8018:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>d});var o=t(7378);const s={},r=o.createContext(s);function i(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);