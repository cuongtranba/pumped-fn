"use strict";(self.webpackChunkpumped_fn_docs=self.webpackChunkpumped_fn_docs||[]).push([[321],{8018:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var r=t(7378);const s={},c=r.createContext(s);function o(e){const n=r.useContext(c);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(c.Provider,{value:n},e.children)}},8449:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"core-concepts/executors","title":"Executors","description":"Executors are the fundamental building blocks of Pumped Fn. They encapsulate state, computations, and side effects in a composable, type-safe way.","source":"@site/docs/core-concepts/executors.md","sourceDirName":"core-concepts","slug":"/core-concepts/executors","permalink":"/pumped-fn/docs/core-concepts/executors","draft":false,"unlisted":false,"editUrl":"https://github.com/pumped-fn/pumped-fn/tree/main/docs/docs/core-concepts/executors.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Your First App","permalink":"/pumped-fn/docs/getting-started/first-app"},"next":{"title":"React Integration Overview","permalink":"/pumped-fn/docs/react/overview"}}');var s=t(6106),c=t(8018);const o={},i="Executors",a={},l=[{value:"What is an Executor?",id:"what-is-an-executor",level:2},{value:"Creating Executors",id:"creating-executors",level:2},{value:"<code>provide()</code> - Independent State",id:"provide---independent-state",level:3},{value:"<code>derive()</code> - Dependent State",id:"derive---dependent-state",level:3},{value:"Executor Variants",id:"executor-variants",level:2},{value:"<code>.reactive</code> - Automatic Updates",id:"reactive---automatic-updates",level:3},{value:"<code>.static</code> - Access to Accessor",id:"static---access-to-accessor",level:3},{value:"<code>.lazy</code> - No Automatic Resolution",id:"lazy---no-automatic-resolution",level:3},{value:"Lifecycle and Side Effects",id:"lifecycle-and-side-effects",level:2},{value:"Controller API",id:"controller-api",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Keep Factory Functions Pure",id:"1-keep-factory-functions-pure",level:3},{value:"2. Use Appropriate Variants",id:"2-use-appropriate-variants",level:3},{value:"3. Handle Side Effects Properly",id:"3-handle-side-effects-properly",level:3},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"executors",children:"Executors"})}),"\n",(0,s.jsx)(n.p,{children:"Executors are the fundamental building blocks of Pumped Fn. They encapsulate state, computations, and side effects in a composable, type-safe way."}),"\n",(0,s.jsx)(n.h2,{id:"what-is-an-executor",children:"What is an Executor?"}),"\n",(0,s.jsx)(n.p,{children:"An executor is a container that holds:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["A ",(0,s.jsx)(n.strong,{children:"factory function"})," that produces a value"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dependencies"})," on other executors (optional)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Metadata"})," for debugging and introspection (optional)"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"creating-executors",children:"Creating Executors"}),"\n",(0,s.jsxs)(n.h3,{id:"provide---independent-state",children:[(0,s.jsx)(n.code,{children:"provide()"})," - Independent State"]}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"provide()"})," to create executors that don't depend on other executors:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",metastring:"live",live:!0,children:"import React from 'react';\nimport { provide } from '@pumped-fn/core-next';\nimport { useResolves, ScopeProvider } from '@pumped-fn/react';\n\n// Simple value\nconst message = provide(() => \"Hello, World!\");\n\n// Complex state\nconst userSettings = provide(() => ({\n  theme: 'dark',\n  notifications: true,\n  language: 'en'\n}));\n\n// Function state\nconst apiClient = provide(() => {\n  return {\n    get: async (url) => {\n      // Mock API call\n      return { data: `Data from ${url}` };\n    }\n  };\n});\n\nfunction ProvideExample() {\n  const [msg, settings, client] = useResolves(message, userSettings, apiClient);\n  \n  return (\n    <div style={{ padding: '20px' }}>\n      <h3>Provide Examples</h3>\n      <p>Message: {msg}</p>\n      <p>Theme: {settings.theme}</p>\n      <p>Notifications: {settings.notifications ? 'On' : 'Off'}</p>\n      <p>API Client: {typeof client.get}</p>\n    </div>\n  );\n}\n\nexport default function App() {\n  return (\n    <ScopeProvider>\n      <ProvideExample />\n    </ScopeProvider>\n  );\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"derive---dependent-state",children:[(0,s.jsx)(n.code,{children:"derive()"})," - Dependent State"]}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"derive()"})," to create executors that depend on other executors:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",metastring:"live",live:!0,children:"import React from 'react';\nimport { provide, derive } from '@pumped-fn/core-next';\nimport { useResolves, ScopeProvider } from '@pumped-fn/react';\n\n// Base state\nconst firstName = provide(() => \"John\");\nconst lastName = provide(() => \"Doe\");\nconst age = provide(() => 25);\n\n// Derived state - single dependency\nconst fullName = derive([firstName.reactive, lastName.reactive], ([first, last]) => {\n  return `${first} ${last}`;\n});\n\n// Derived state - object dependencies\nconst person = derive(\n  { firstName: firstName.reactive, lastName: lastName.reactive, age: age.reactive },\n  ({ firstName, lastName, age }) => ({\n    name: `${firstName} ${lastName}`,\n    age,\n    isAdult: age >= 18\n  })\n);\n\n// Derived state - dependent on derived state\nconst greeting = derive([fullName.reactive], ([name]) => {\n  return `Hello, ${name}!`;\n});\n\nfunction DeriveExample() {\n  const [full, personInfo, greet] = useResolves(fullName, person, greeting);\n  \n  return (\n    <div style={{ padding: '20px' }}>\n      <h3>Derive Examples</h3>\n      <p>Full Name: {full}</p>\n      <p>Person: {personInfo.name}, Age: {personInfo.age}</p>\n      <p>Is Adult: {personInfo.isAdult ? 'Yes' : 'No'}</p>\n      <p>Greeting: {greet}</p>\n      \n      <div style={{ marginTop: '20px' }}>\n        <button onClick={() => firstName.update('Jane')}>\n          Change First Name\n        </button>\n        <button onClick={() => age.update(17)} style={{ marginLeft: '10px' }}>\n          Make Minor\n        </button>\n      </div>\n    </div>\n  );\n}\n\nexport default function App() {\n  return (\n    <ScopeProvider>\n      <DeriveExample />\n    </ScopeProvider>\n  );\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"executor-variants",children:"Executor Variants"}),"\n",(0,s.jsx)(n.p,{children:"Each executor has different variants that control how they interact with dependencies:"}),"\n",(0,s.jsxs)(n.h3,{id:"reactive---automatic-updates",children:[(0,s.jsx)(n.code,{children:".reactive"})," - Automatic Updates"]}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".reactive"})," when you want the derived executor to re-run whenever the dependency changes:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const count = provide(() => 0);\nconst doubled = derive([count.reactive], ([count]) => count * 2);\n// doubled updates automatically when count changes\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"static---access-to-accessor",children:[(0,s.jsx)(n.code,{children:".static"})," - Access to Accessor"]}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".static"})," when you need access to the full accessor (for updates, metadata, etc.):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const count = provide(() => 0);\nconst incrementer = derive([count.static], ([countAccessor]) => {\n  return () => countAccessor.update(c => c + 1);\n});\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"lazy---no-automatic-resolution",children:[(0,s.jsx)(n.code,{children:".lazy"})," - No Automatic Resolution"]}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:".lazy"})," when you want to control when the dependency is resolved:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const expensiveComputation = provide(() => /* expensive work */);\nconst controller = derive([expensiveComputation.lazy], ([lazyAccessor]) => {\n  return {\n    compute: () => lazyAccessor.resolve(),\n    getValue: () => lazyAccessor.get()\n  };\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"lifecycle-and-side-effects",children:"Lifecycle and Side Effects"}),"\n",(0,s.jsx)(n.p,{children:"Executors can perform side effects and cleanup:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",metastring:"live",live:!0,children:"import React from 'react';\nimport { provide, derive } from '@pumped-fn/core-next';\nimport { useResolves, ScopeProvider } from '@pumped-fn/react';\n\nconst interval = provide(() => 1000);\nconst counter = provide(() => 0);\n\n// Executor with side effects\nconst timer = derive(\n  [interval.reactive, counter.static],\n  ([intervalMs, counterAccessor], controller) => {\n    console.log(`Starting timer with ${intervalMs}ms interval`);\n    \n    const intervalId = setInterval(() => {\n      counterAccessor.update(c => c + 1);\n    }, intervalMs);\n    \n    // Cleanup function\n    controller.cleanup(() => {\n      console.log('Cleaning up timer');\n      clearInterval(intervalId);\n    });\n    \n    return {\n      intervalId,\n      stop: () => clearInterval(intervalId)\n    };\n  }\n);\n\nfunction TimerExample() {\n  const [count, timerInfo, intervalMs] = useResolves(counter, timer, interval);\n  \n  return (\n    <div style={{ padding: '20px' }}>\n      <h3>Timer Example</h3>\n      <p>Count: {count}</p>\n      <p>Interval: {intervalMs}ms</p>\n      <p>Timer ID: {timerInfo.intervalId}</p>\n      \n      <div style={{ marginTop: '20px' }}>\n        <button onClick={() => interval.update(500)}>\n          Faster (500ms)\n        </button>\n        <button onClick={() => interval.update(2000)} style={{ marginLeft: '10px' }}>\n          Slower (2000ms)\n        </button>\n      </div>\n    </div>\n  );\n}\n\nexport default function App() {\n  return (\n    <ScopeProvider>\n      <TimerExample />\n    </ScopeProvider>\n  );\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"controller-api",children:"Controller API"}),"\n",(0,s.jsx)(n.p,{children:"The controller parameter provides lifecycle management:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"derive(dependencies, (deps, controller) => {\n  // Cleanup function - called when:\n  // - The executor is updated\n  // - The executor is released\n  // - The scope is disposed\n  controller.cleanup(() => {\n    console.log('Cleaning up');\n  });\n  \n  // Release this executor\n  controller.release();\n  \n  // Access to the current scope\n  const scope = controller.scope;\n  \n  return value;\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"1-keep-factory-functions-pure",children:"1. Keep Factory Functions Pure"}),"\n",(0,s.jsx)(n.p,{children:"Factory functions should be pure when possible:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Good - pure function\nconst doubled = derive([count.reactive], ([count]) => count * 2);\n\n// Avoid - side effects in factory\nconst doubled = derive([count.reactive], ([count]) => {\n  console.log('Computing doubled'); // Side effect\n  return count * 2;\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-use-appropriate-variants",children:"2. Use Appropriate Variants"}),"\n",(0,s.jsx)(n.p,{children:"Choose the right variant for your use case:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:".reactive"})," for automatic updates"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:".static"})," for accessing the full accessor"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:".lazy"})," for delayed resolution"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"3-handle-side-effects-properly",children:"3. Handle Side Effects Properly"}),"\n",(0,s.jsx)(n.p,{children:"Always clean up side effects:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const subscription = derive([source.reactive], ([source], controller) => {\n  const sub = source.subscribe(handler);\n  \n  controller.cleanup(() => {\n    sub.unsubscribe();\n  });\n  \n  return sub;\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsx)(n.p,{children:"Now that you understand executors, explore:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/pumped-fn/docs/react/overview",children:"React Integration"})," - Using executors in React components"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/pumped-fn/docs/examples/counter",children:"Examples"})," - More practical examples"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);